package wordLadder2;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.Map;
import java.util.Queue;
import java.util.Set;

//Given two words (start and end), and a dictionary, find all shortest transformation sequence(s)
// from start to end, such that:
//
//Only one letter can be changed at a time
//Each intermediate word must exist in the dictionary
//For example,
//
//Given:
//start = "hit"
//end = "cog"
//dict = ["hot","dot","dog","lot","log"]
//Return
//  [
//    ["hit","hot","dot","dog","cog"],
//    ["hit","hot","lot","log","cog"]
//  ]
//Note:
//All words have the same length.
//All words contain only lowercase alphabetic characters.
public class Solution {
	// this approach uses BFS to search for the lowest solution, stop at the lowest level
	//  	note during BFS, we can't blindly ignore visited nodes, because we might see the following(start == red, end == tax)
	//                      red
	//               ted          rex
	//            tad   tex       tex
	//            tax   tax       tax
	//      in which case 'tex' under 'rex' shouldn't be ignored
	//      therefore, besides maintaining a visited set, we also maintain a levelVisited set, 
	//           1) if a node is visited at this level, we need to add it again
	//           2) if a node is visited but not visited at this level, it's visited in upper levels, 
	//              in the latter case, we don't need to add the node, because had there been a solution on the dup node, the solution path generated by the upper node S1, 
	//              would be shorter than the solution path generated by the later node S2, then S2 will be dropped
	//            there fore for 2) we don't add the new node 
	// then build a map of <Node, parents>, then use DFS to recreate the solution tree
	public ArrayList<ArrayList<String>> findLadders(String start, String end,
			HashSet<String> dict) {
		ArrayList<ArrayList<String>> ret = new ArrayList<ArrayList<String>>();
		Set<String> visited = new HashSet<String>();
		Set<String> levelVisited = new HashSet<String>();
		Queue<String> q = new ArrayDeque<String>();
		// what's the parent of String s in the tree? S might get multiple
		// parents
		Map<String, Set<String>> parents = new HashMap<String, Set<String>>();
		q.offer(start);
		q.offer("\0");
		boolean newLvl = true;
		int len = start.length();
		char[] backArr = new char[len];
		boolean stop = false;
		while (!q.isEmpty()) {
			String next = q.poll();
			visited.add(next);
			// no nodes btn two level, no more, we're done
			if (next.equals("\0"))
				return ret;
			if (newLvl) {
				levelVisited.clear();
				newLvl = false;
			}
			if (q.peek().equals("\0")) {
				newLvl = true;
				q.poll();
			}
			here: for (int i = 0; i < len; i++) {
				backArr = next.toCharArray();
				for (char c = 'a'; c <= 'z'; c++) {
					backArr[i] = c;
					String newStr = new String(backArr);
					if (newStr.equals(end)) {
						stop = true;
						if (parents.containsKey(newStr)) {
							parents.get(newStr).add(next);
						} else {
							Set<String> newSet = new HashSet<String>();
							newSet.add(next);
							parents.put(newStr, newSet);
						}
						break here;
					}
					if (dict.contains(newStr)) {
						if (!visited.contains(newStr)) {
							// if the node is not yet visited, need to add it
							// into queue
							visited.add(newStr);
							levelVisited.add(newStr);
							q.offer(newStr);
							if (parents.containsKey(newStr)) {
								parents.get(newStr).add(next);
							} else {
								Set<String> newSet = new HashSet<String>();
								newSet.add(next);
								parents.put(newStr, newSet);
							}
						}
						// other wise this node is added before,
						// if this node is added in current level, then we can
						// still add it,
						// if this node is added in previous level, then adding
						// it again will only makes path longer, we don't add it
						else {
							// this node is visited, and it's visited in current
							// level, it must have been added
							if (levelVisited.contains(newStr)) {
								parents.get(newStr).add(next);
							}
						}
					}
				}
			}
			if (newLvl) {
				// if this is the last node of this level and we have already
				// find at least an answer in this level, we won't probe further
				if (stop) {
					break;
				}
				q.offer("\0");
			}
		}

		// build ret using DFS
		LinkedList<String> backList = new LinkedList<String>();
		buildRet(parents, start, end, backList, ret);
		return ret;
	}

	void buildRet(Map<String, Set<String>> parents, String start,
			String current, LinkedList<String> backList,
			ArrayList<ArrayList<String>> ret) {
		if (current.equals(start)) {
			ArrayList<String> newList = new ArrayList<String>();
			newList.add(start);
			newList.addAll(backList);
			ret.add(newList);
		} else {
			backList.addFirst(current);
			for (String parent : parents.get(current)) {
				buildRet(parents, start, parent, backList, ret);
			}
			backList.removeFirst();
		}
	}

	// this is a BFS without considering visited, it's depending on the fact
	// that if we found a answer at level n, then we only search all nodes at
	// this level,
	// therefore we won't go infinite, but this will create a tree of big
	// fan-out
	// and in the case when there's no answer, it will jump back and forth btn
	// two nodes
	public ArrayList<ArrayList<String>> findLaddersNoVisit(String start,
			String end, HashSet<String> dict) {
		ArrayList<ArrayList<String>> ret = new ArrayList<ArrayList<String>>();

		Queue<Node> q = new ArrayDeque<Node>();
		q.offer(new Node(start));
		q.offer(new Node("\0"));
		boolean newLvl = true;
		int len = start.length();
		char[] backArr = new char[len];
		boolean stop = false;
		while (!q.isEmpty()) {
			Node next = q.poll();
			// no nodes btn two level, no more, we're done
			if (next.s.equals("\0"))
				return ret;
			if (newLvl) {
				newLvl = false;
			}
			if (q.peek().s.equals("\0")) {
				newLvl = true;
				q.poll();
			}
			here: for (int i = 0; i < len; i++) {
				backArr = next.s.toCharArray();
				for (char c = 'a'; c <= 'z'; c++) {
					backArr[i] = c;
					String newStr = new String(backArr);
					if (newStr.equals(end)) {
						stop = true;
						ArrayList<String> newList = new ArrayList<String>();
						newList.add(0, end);
						while (next != null) {
							newList.add(0, next.s);
							next = next.prev;
						}
						ret.add(newList);
						break here;
					}
					if (!newStr.equals(next.s) && dict.contains(newStr)) {
						Node n = new Node(newStr);
						n.prev = next;
						q.offer(n);
					}
				}
			}
			if (newLvl) {
				// if this is the last node of this level and we have already
				// find at least an answer in this level, we won't probe further
				if (stop) {
					break;
				}
				q.offer(new Node("\0"));
			}
		}
		return ret;
	}

	// this is a real BFS, we probe the nodes that's not visited on this path,
	// as opposed to not visited globally
	public ArrayList<ArrayList<String>> findLaddersNaive(String start,
			String end, HashSet<String> dict) {
		ArrayList<ArrayList<String>> ret = new ArrayList<ArrayList<String>>();

		Queue<Node> q = new ArrayDeque<Node>();
		q.offer(new Node(start));
		q.offer(new Node("\0"));
		boolean newLvl = true;
		int len = start.length();
		char[] backArr = new char[len];
		boolean stop = false;
		while (!q.isEmpty()) {
			Node next = q.poll();
			// no nodes btn two level, no more, we're done
			if (next.s.equals("\0"))
				return ret;
			if (newLvl) {
				newLvl = false;
			}
			if (q.peek().s.equals("\0")) {
				newLvl = true;
				q.poll();
			}
			here: for (int i = 0; i < len; i++) {
				backArr = next.s.toCharArray();
				for (char c = 'a'; c <= 'z'; c++) {
					backArr[i] = c;
					String newStr = new String(backArr);
					if (newStr.equals(end)) {
						stop = true;
						ArrayList<String> newList = new ArrayList<String>();
						newList.add(0, end);
						while (next != null) {
							newList.add(0, next.s);
							next = next.prev;
						}
						ret.add(newList);
						break here;
					}
					if (dict.contains(newStr) && !next.visited(newStr)) {
						Node n = new Node(newStr);
						n.prev = next;
						q.offer(n);
					}
				}
			}
			if (newLvl) {
				// if this is the last node of this level and we have already
				// find at least an answer in this level, we won't probe further
				if (stop) {
					break;
				}
				q.offer(new Node("\0"));
			}
		}
		return ret;
	}

	class Node {
		Node prev;
		String s;

		public Node(String s) {
			this.s = s;
		}

		// check if we have visited a string along the path
		public boolean visited(String s) {
			Node n = prev;
			while (n != null) {
				if (n.s.equals(s))
					return true;
				n = n.prev;
			}
			return false;
		}

		@Override
		public String toString() {
			return s + " ";
		}
	}

	public static void main(String[] args) {
		HashSet<String> dict = new HashSet<String>();
		// dict.add("ab");
		// dict.add("a");
		// dict.add("c");
		// dict.add("b");
		// String[] dictStr = { "ted", "tex", "red", "tax", "tad", "den", "rex",
		// "pee" };
		String[] dictStr = { "a", "c", "b" };
		for (String s : dictStr) {
			dict.add(s);
		}
		for (ArrayList<String> list : new Solution()
				.findLadders("a", "c", dict)) {
			for (String s : list) {
				System.out.print(s + " ");
			}
			System.out.println();
		}
	}
}
